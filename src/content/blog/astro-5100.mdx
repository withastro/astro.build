---
title: 'Astro 5.10'
description: 'Astro 5.10 brings responsive images for everyone, plus experimental live content collections, CSP improvements, and more'
homepageLink:
  title: 'Astro 5.10'
  subtitle: 'Available now!'
publishDate: '2025-06-19'
authors:
  - matt
coverImage: '/src/content/blog/_images/astro-5100/blog-post-5-10.webp'
socialImage: '/src/content/blog/_images/astro-5100/og-astro-5-10.webp'
lang: 'en'
---

import Mention from '/src/components/Mention.astro';

**ðŸŽ¥ This time we're doing it live â€“ and we're always responsive to your needs**

Astro 5.10 brings responsive images for everyone, plus experimental live content collections, CSP improvements, and more

- [**Experimental live content collections**](#experimental-live-content-collections)
- [**Responsive images are now stable**](#responsive-images-are-now-stable)
- [**Improvements to experimental Content Security Policy**](#improvements-to-experimental-content-security-policy)

To upgrade an existing project, use the automated `@astrojs/upgrade` CLI tool. Alternatively, upgrade manually by running the upgrade command for your package manager:

```sh
# Recommended:
npx @astrojs/upgrade

# Manual:
npm install astro@latest
pnpm upgrade astro --latest
yarn upgrade astro --latest
```

## Experimental live content collections

Astro 5.10 introduces a new experimental feature: live content collections. This powerful addition allows you to fetch content at runtime instead of build time, opening up new possibilities for dynamic, real-time content.

Built-time content collections are perfect for content that doesn't change a lot, or where your site is quick and easy to rebuild when it changes, but what about data that changes frequently, or that needs to be personalized to the user? Live content collections fill this gap by letting you fetch fresh data on every request.

### How it works

Live content collections use a new type of loader that fetches data at runtime. Unlike existing loaders that run during the build process, live loaders execute when users visit your pages, ensuring you always have the latest data.

For the best performance you should still use build-time collections where possible, but use live collections for data that needs to be right up-to-date, or where you want to filter or personalize the data based on user input, credentials, or preferences.

To get started, enable experimental live content collections in your Astro config:

```js title="astro.config.mjs" ins={3}
export default defineConfig({
	experimental: {
		liveContentCollections: true,
	},
});
```

Create a `src/live.config.ts` file to define your live collections:

```ts title="src/live.config.ts"
import { defineLiveCollection } from 'astro:content';
import { storeLoader } from './loaders/store';

export const products = defineLiveCollection({
	type: 'live',
	loader: storeLoader({
		apiKey: process.env.STORE_API_KEY,
		endpoint: 'https://api.mystore.com/v1',
	}),
});
```

### Fetching live data

Use the new `getLiveCollection` and `getLiveEntry` functions to fetch data in your components:

```astro title="src/pages/products/[slug].astro"
---
import { getLiveEntry } from 'astro:content';

const { entry: product, error } = await getLiveEntry(
	'products',
	Astro.params.slug,
);

if (error) {
	console.error('Failed to load product:', error);
	return Astro.rewrite('/404');
}
---

<h1>{product.data.name}</h1>
<p>
	{
		Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(
			product.data.price,
		)
	}
</p>
```

### Rendering live content

Live loaders can generate rendered content, like build-time loaders, making it super easy to display dynamic data in your components:

```astro title="src/pages/products/[slug].astro" "<Content />" "render(product)"
---
import { getLiveEntry, render } from 'astro:content';

const { entry: product, error } = await getLiveEntry(
	'products',
	Astro.params.slug,
);

if (error) {
	console.error('Failed to load product:', error);
	return Astro.rewrite('/404');
}

const { Content } = await render(product);
---

<h1>{product.data.name}</h1>

<Content />
```

### Flexible filtering

Live loaders support loader-specific query and filter options, allowing you to push filtering logic to the API level for more efficient data fetching. This means you can request exactly the data you need rather than fetching everything and filtering client-side.

```astro title="src/pages/products.astro"
---
import { getLiveCollection } from 'astro:content';

const { entries, error } = await getLiveCollection('products', {
	category: 'electronics',
	priceRange: { min: 10, max: 100 },
});
---
```

### Error handling

Live content collections provide explicit error handling with result objects that contain either data or an `error` object. This makes runtime behavior predictable and helps you handle failures gracefully.

### Type safety

It wouldn't be Astro if it wasn't built with type-safety in mind, so the API is fully type-safe, with generic types ensuring your data and query options are correctly typed:

```ts
// Custom loader with typed queries and data
const { entry, error } = await getLiveEntry('products', {
	uuid: Astro.params.uuid, // Filter options are type-checked
});
// `entry` will be typed
```

Live content collections are experimental and we're actively seeking feedback from the community. Try them out in your projects and let us know how they work for you!

For more details, including how to build live loaders, see the [experimental live content collections documentation](https://docs.astro.build/en/reference/experimental-flags/live-content-collections/). Give us your feedback on [the RFC](https://github.com/withastro/roadmap/pull/1164).

## Responsive images are now stable

The Astro responsive images feature is now stable and ready for production!

Responsive images automatically generate optimized `srcset` and `sizes` attributes, and can generate the styles needed to ensure your images load quickly and display beautifully across all screen sizes. Say goodbye to layout shifts and slow-loading images that hurt your Core Web Vitals scores.

### Get started with responsive images

Most people should enable automatic styles for responsive images in your `astro.config.mjs` file:

```js title="astro.config.mjs" ins={3}
export default defineConfig({
	image: {
		responsiveStyles: true,
	},
});
```

You enable responsive images by setting a `layout`, either globally in your Astro config or on a per-image basis.

```js title="astro.config.mjs" {4}
export default defineConfig({
	image: {
		responsiveStyles: true,
		layout: 'constrained',
	},
});
```

**Layout options:** Choose from `constrained`, `fixed`, or `full-width` layouts to control how your images behave:

```astro
<Image
	src="/hero.jpg"
	alt="A panoramic view of the mountains"
	layout="full-width"
/>
```

**Priority loading:** Use the new `priority` prop to optimize critical images that appear above the fold:

```astro
<Image src="/hero.jpg" alt="Hero image" priority />
```

When you add `priority`, Astro automatically sets `loading="eager"`, `decoding="sync"`, and `fetchpriority="high"` to ensure the image loads immediately. Use this sparingly â€“ ideally only one image per page should have priority loading. A good rule of thumb is to check if your [LCP element](https://web.dev/lcp/#lcp-element) is an image, and if so, set the `priority` flag on it.

**Enhanced cropping controls:** The `fit` and `position` properties give you precise control over how images are cropped and positioned:

```astro
<Image
	src="/profile.jpg"
	alt="Profile photo"
	fit="cover"
	position="center top"
	width={300}
	height={300}
/>
```

### Upgrading from experimental responsive images

If you were using experimental responsive images, you should remove the experimental flag from your `astro.config.mjs` file:

```js title="astro.config.mjs" del={3} ins={6}
export default defineConfig({
	experimental: {
		responsiveImages: true,
	},
	image: {
		responsiveStyles: true,
	},
});
```

For complete details, see the [Images guide](https://docs.astro.build/en/guides/images/).

## Improvements to experimental Content Security Policy

Astro 5.9 shipped experimental support for Content Security Policy (CSP) meta tags, bringing powerful security features to your Astro sites. In 5.10, we've made several improvements based on community feedback. The most important is that we now support generating CSP headers, including for static pages.

On-demand rendered pages will now send Response headers for CSP, rather than meta tags. This improves performance in Chrome, and adds support for more directives, like `report-uri` and `frame-ancestors`, which are not supported in meta tags.

By default, prerendered pages will still use meta tags, but there is now core support for generating headers for prerendered pages as well. Eventually, this will be implemented in all adapters, but currently only the `@astrojs/netlify` and `@astrojs/vercel` adapters support it. To enable this, ensure you have updated to the latest version of the adapter and add the `experimentalStaticHeaders` option to your adapter configuration:

```js title="astro.config.mjs" {6}
import { defineConfig } from 'astro/config';
import netlify from '@astrojs/netlify';

export default defineConfig({
	adapter: netlify({
		experimentalStaticHeaders: true,
	}),
	experimental: {
		csp: true,
	},
});
```

For more details, see the [experimental CSP documentation](https://docs.astro.build/en/reference/experimental-flags/csp/).

## Bug fixes

As always, we've been working hard on fixing issues since the [5.9 release](/blog/astro-590). See [the changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) for all the details.

## Community

The Astro core team is:

<Mention name="ben" />, <Mention name="caleb" />, <Mention name="chris" />,
<Mention name="ema" />, <Mention name="erika" />, <Mention name="florian" />,
<Mention name="fred" />, <Mention name="fuzzy" />, <Mention name="hideoo" />,
<Mention name="luiz" />, <Mention name="matt" />, <Mention name="matthew" />,
<Mention name="nate" />, <Mention name="reuben" />, <Mention name="sarah" />,
and <Mention name="yan" />.

import RelatedPosts from './_components/RelatedPosts.astro';

<RelatedPosts slugs={['astro-590', 'astro-580']} />
